; HEX16 0 <# # # # # #> TYPE ;
        head HEX16,5,HEX16,docolon
	DW LIT,0
	DW LESSNUM,NUM,NUM,NUM,NUM,NUMGREATER
	DW TYPE,EXIT

; HEX8 0 <# # # #> TYPE ;
        head HEX8,4,HEX8,docolon
	DW LIT,0
	DW LESSNUM,NUM,NUM,NUMGREATER
	DW TYPE,EXIT

; ADDR HEX16 [CHAR] : EMIT SPACE ;
        head ADDR,4,ADDR,docolon
	DW HEX16,LIT,':',EMIT,LIT,' ',EMIT
	DW EXIT

; DUMPLINE DUP ADDR DUP 10 + SWAP DO I C@ HEX8 SPACE LOOP ;
        head DUMPLINE,8,DUMPLINE,docolon
	DW DUP,ADDR,DUP,LIT,10h,PLUS,SWOP,XDO
DXX1:   DW II,CFETCH,HEX8,LIT,' ',EMIT,XLOOP,DXX1
	DW EXIT

; DUMPCHAR DUP 20 < OVER 7F > OR IF DROP [CHAR] . THEN EMIT ;
        head DUMPCHAR,8,DUMPCHAR,docolon
	DW DUP,LIT,20h,LESS,OVER,LIT,7fh,GREATER,OR,qbranch,DXX2
	DW DROP,LIT,'.'
DXX2:   DW EMIT,EXIT

; DUMPASCII DUP 10 + SWAP DO I C@ DUMPCHAR LOOP ;
        head DUMPASCII,9,DUMPASCII,docolon
        DW DUP,LIT,10h,PLUS,SWOP,XDO
DXX3:   DW II,CFETCH,DUMPCHAR,XLOOP,DXX3
        DW EXIT

; DUMP BASE @ >R HEX 0D EMIT DUP 80 + SWAP DO I DUMPLINE 3 SPACES I DUMPASCII CR 10 +LOOP R> BASE ! ;
        head DUMP,4,DUMP,docolon
        DW BASE,FETCH,TOR,HEX,LIT,0dh,EMIT,DUP,LIT,80h,PLUS,SWOP,XDO
DXX4:   DW II,DUMPLINE,LIT,3,SPACES,II,DUMPASCII,CR,LIT,10h
        DW XPLUSLOOP,DXX4
        DW RFROM,BASE,STORE,EXIT

; 20 CONSTANT R_DATA      ( R/W )  
        head R_DATA,6,R_DATA,docon
        DW 20h

; 21 CONSTANT R_SECTCNT   ( W/O ) 
        head R_SECTCNT,9,R_SECTCNT,docon
        DW 21h

; 22 CONSTANT R_FEATURES  ( W/O ) 
        head R_FEATURES,10,R_FEATURES,docon
        DW 22h

; 23 CONSTANT R_LBA_LL    ( W/O )
        head RLBALL,8,R_LBA_LL,docon
        DW 23h

; 24 CONSTANT R_LBA_LH    ( W/O )
        head RLBALH,8,R_LBA_LH,docon
        DW 24h

; 25 CONSTANT R_LBA_HH    ( W/O )
        head RLBAHH,8,R_LBA_HH,docon
        DW 25h

; 26 CONSTANT R_LBA_HL    ( W/O )
        head RLBAHL,8,R_LBA_HL,docon
        DW 26h

; 27 CONSTANT R_CMD       ( W/O )
        head R_CMD,5,R_CMD,docon
        DW 27h

; 22 CONSTANT R_ERRORS    ( R/O )
        head R_ERRORS,8,R_ERRORS,docon
        DW 22h

; 27 CONSTANT R_STATUS    ( R/O )
        head R_STATUS,8,R_STATUS,docon
        DW 27h

; 35 CONSTANT R_DEVCTL    ( W/O )
        head R_DEVCTL,8,R_DEVCTL,docon
        DW 35h

; 35 CONSTANT R_ALTSTATUS ( R/O )
        head R_ALTSTATUS,11,R_ALTSTATUS,docon
        DW 35h

; 37 CONSTANT R_DRIVEADDR ( R/O )
        head R_DRIVEADDR,11,R_DRIVEADDR,docon
        DW 37h

; 1C CONSTANT R_DATLO
        head R_DATLO,7,R_DATLO,docon
        DW 1ch

; 1E CONSTANT R_DATHI
        head R_DATHI,7,R_DATHI,docon
        DW 1eh

; 4000 CONSTANT LOADERBASE
        head LOADERBASE,10,LOADERBASE,docon
        DW 4000h

; CREATE BUFFER 200 ALLOT
        head BUFFER,6,BUFFER,docreate
        DS 200h

; VARIABLE IOMODE 10 IOMODE !
        head IOMODE,6,IOMODE,dovar
        DW 10h

; CREATE COPIER ( Store boot program )
	head COPIER,6,COPIER,docreate
	DB COPI1L-$-1
	DB 021h,000h,041h ; ( ld hl,4100h )
	DB 011h,000h,001h ; ( ld de,0100h )
	DB 001h,000h,03Fh ; ( ld bc,3f00h )
	DB 0EDh,0B0h      ; ( ldir )
	DB 0DBh,019h      ; ( in a,[19h] ) 
	DB 0E6h,004h      ; ( and 004h )
	DB 0CAh,00Bh,040h ; ( jp nz,400bh )
	DB 03Eh,031h      ; ( ld a,'1' )
	DB 0D3h,018h      ; ( out [18h],a )
	DB 0C3h,000h,001h ; ( jp 0100h )
COPI1L:	equ $
	; DB HERE COPIER - 1- COPIER C!

; CREATE SKIPCOPIER ( Store boot program )
	head SKIPCOPIER,10,SKIPCOPIER,docreate
	DB COPI2L-$-1
	DB 021h,000h,04Ah ; ( ld hl,4a00h )
	DB 011h,000h,0DCh ; ( ld de,dc00h )
	DB 001h,000h,023h ; ( ld bc,2300h )
	DB 0EDh,0B0h      ; ( ldir )
	DB 0DBh,019h      ; ( in a,[19h] ) 
	DB 0E6h,004h      ; ( and 004h )
	DB 0CAh,00Bh,040h ; ( jp nz,400bh )
	DB 03Eh,033h      ; ( ld a,'3' )
	DB 0D3h,018h      ; ( out [18h],a )
	DB 0C3h,000h,0F2h ; ( jp f200h )
COPI2L:	equ $
	; HERE SKIPCOPIER - 1- SKIPCOPIER C!

; IDEIN ( -- ) 4F 1D PC! 4F 1F PC! ;
        head IDEIN,5,IDEIN,docolon
	DW LIT,4fh,LIT,1dh,PCSTORE
	DW LIT,4fh,LIT,1fh,PCSTORE
	DW EXIT

; IDEOUT ( -- ) 0F 1D PC! 0F 1F PC! ;
        head IDEOUT,6,IDEOUT,docolon
	DW LIT,0fh,LIT,1dh,PCSTORE
	DW LIT,0fh,LIT,1fh,PCSTORE
	DW EXIT

; CMD ( idecmd -- ) IDEOUT R_DATLO PC! 0 R_CMD PC! IDEIN ;
        head CMD,3,CMD,docolon
	DW IDEOUT,R_DATLO,PCSTORE,LIT,0,R_CMD,PCSTORE,IDEIN,EXIT

; READSTATUS ( -- ) R_STATUS PC@ DROP R_DATLO PC@ ;
	head READSTATUS,10,READSTATUS,docolon
	DW R_STATUS,PCFETCH,DROP,R_DATLO,PCFETCH,EXIT

; WAITREADY ( -- ) BEGIN READSTATUS 80 AND 0= UNTIL ; ( Wait for bit 7 to clear )
	head WAITREADY,9,WAITREADY,docolon
WAITR1:DW READSTATUS,LIT,80h,AND,ZEROEQUAL,qbranch,WAITR1,EXIT


; WAITDRQ ( -- ) BEGIN READSTATUS 08 AND UNTIL ; ( Wait for bit 3 to set )
	head WAITDRQ,7,WAITDRQ,docolon
WAITD1:DW READSTATUS,LIT,08h,AND,qbranch,WAITD1,EXIT

; BUFFERREAD16 ( -- ) WAITDRQ 100 0 DO R_DATA PC@ DROP R_DATLO PC@ BUFFER I 2* + C! R_DATHI PC@ BUFFER I 2* + 1+ C! LOOP ;
	head BRD16,12,BUFFERREAD16,docolon
	DW WAITDRQ,LIT,100h,LIT,0,XDO
BRD161:	DW R_DATA,PCFETCH,DROP,R_DATLO,PCFETCH,BUFFER,II,TWOSTAR,PLUS
	DW CSTORE,R_DATHI,PCFETCH,BUFFER,II,TWOSTAR,PLUS,ONEPLUS,CSTORE
	DW XLOOP,BRD161
	DW EXIT

; BUFFERWRITE16 ( -- ) WAITDRQ IDEOUT 100 0 DO BUFFER I 2* + DUP C@ R_DATLO PC! 1+ C@ R_DATHI PC! 0 R_DATA PC! LOOP IDEIN ;
	head BWR16,13,BUFFERWRITE16,docolon
	DW WAITDRQ,IDEOUT,LIT,100h,LIT,0,XDO
BWR161:	DW BUFFER,II,TWOSTAR,PLUS,DUP,CFETCH,R_DATLO,PCSTORE,ONEPLUS
	DW CFETCH,R_DATHI,PCSTORE,LIT,0,R_DATA,PCSTORE,XLOOP,BWR161
	DW IDEIN,EXIT

; BUFFERREAD8 ( -- ) WAITDRQ 200 0 DO R_DATA PC@ DROP R_DATLO PC@ R_DATA PC@ DROP R_DATLO PC@ >< OR BUFFER I + ! 2 +LOOP ;
	head BRD8,11,BUFFERREAD8,docolon
	DW WAITDRQ,LIT,200h,LIT,0,XDO
BRD81:	DW R_DATA,PCFETCH,DROP,R_DATLO,PCFETCH,R_DATA,PCFETCH,DROP
	DW R_DATLO,PCFETCH,SWAPBYTES,OR,BUFFER,II,PLUS,STORE
	DW LIT,2,XPLUSLOOP,BRD81
	DW EXIT

; WRITEWORD8 ( n -- ) DUP R_DATLO PC! 0 R_DATA PC! >< R_DATLO PC! 0 R_DATA PC! ;
	head WRTW8,10,WRITEWORD8,docolon
	DW DUP,R_DATLO,PCSTORE,LIT,0,R_DATA,PCSTORE,SWAPBYTES
	DW R_DATLO,PCSTORE,LIT,0,R_DATA,PCSTORE
	DW EXIT

; BUFFERWRITE8 ( -- ) WAITDRQ IDEOUT 200 0 DO BUFFER I + @ WRITEWORD8 2 +LOOP IDEIN ;
	head BWR8,12,BUFFERWRITE8,docolon
	DW WAITDRQ,IDEOUT,LIT,200h,LIT,0,XDO
BWR81:	DW BUFFER,II,PLUS,FETCH,WRTW8,LIT,2,XPLUSLOOP,BWR81
	DW IDEIN,EXIT

; BUFFERREAD ( -- ) IOMODE @ 8 = IF BUFFERREAD8 ELSE BUFFERREAD16 THEN ;
	head BFRD,10,BUFFERREAD,docolon
	DW IOMODE,FETCH,LIT,8,EQUAL,qbranch,BFRD1
	DW BRD8,branch,BFRD2
BFRD1:	DW BRD16
BFRD2:	DW EXIT

; BUFFERWRITE ( -- ) IOMODE @ 8 = IF BUFFERWRITE8 ELSE BUFFERWRITE16 THEN ;
	head BFWR,11,BUFFERWRITE,docolon
	DW IOMODE,FETCH,LIT,8,EQUAL,qbranch,BFWR1
	DW BWR8,branch,BFWR2
BFWR1:	DW BWR16
BFWR2:	DW EXIT

; WREG ( data reg -- ) IDEOUT SWAP FF AND R_DATLO PC! 0 SWAP PC! IDEIN ;
	head WREG,4,WREG,docolon
	DW IDEOUT,SWOP,LIT,0ffh,AND,R_DATLOW,PCSTORE
	DW LIT,0,SWOP,PCSTORE,IDEIN,EXIT

; RREG ( reg -- ) PC@ DROP R_DATLO PC@ ; 
	head RREG,4,RREG,docolon
	DW PCFETCH,DROP,R_DATLO,PCFETCH,EXIT

; RESET ( -- ) 04 R_DEVCTL WREG 00 R_DEVCTL WREG ;
	head IRESET,5,RESET,docolon
	DW LIT,6,R_DEVCTL,WREG,LIT,2,R_DEVCTL,WREG,EXIT

; IDENT ( -- ) EC CMD BUFFERREAD ;
	head IDENT,5,IDENT,docolon
	DW LIT,0ech,CMD,BFRD,EXIT

; SETSECTCNT ( sectors -- ) R_SECTCNT WREG ;
	head SETSECTCNT,10,SETSECTCNT,docolon
	DW R_SECTCNT,WREG,EXIT

; SETLBA ( sl sh -- ) 1 SETSECTCNT DUP R_LBA_HL WREG >< 0F AND E0 OR R_LBA_HH WREG DUP R_LBA_LL WREG >< R_LBA_LH WREG ;
	head SETLBA,6,SETLBA,docolon
	DW LIT,1,SETSECTCNT
	DW DUP,RLBAHL,WREG,SWAPBYTES,LIT,00fh,AND,LIT,0e0h,OR,RLBAHH,WREG
	DW DUP,RLBALL,WREG,SWAPBYTES,RLBALH,WREG
	DW EXIT

; SWRITE ( sl sh -- ) WAITREADY SETLBA 30 CMD BUFFERWRITE ;
	head SWRITE,6,SWRITE,docolon
	DW WAITREADY,SETLBA,LIT,30h,CMD,BFWR,EXIT

; SREAD ( sl sh -- ) WAITREADY SETLBA 20 CMD BUFFERREAD ; 
	head SREAD,5,SREAD,docolon
	DW WAITREADY,SETLBA,LIT,20h,CMD,BFRD,EXIT

; STATUS ( -- ) ." S=" R_STATUS RREG . ." E=" R_ERRORS RREG . ;
	head STATUS,6,STATUS,docolon
	DW XSQUOTE
	DB 2,'S='
	DW TYPE,R_STATUS,RREG,DOT,XSQUOTE
	DB 2,'E='
	DW TYPE,R_ERRORS,RREG,DOT,EXIT

; BFILL ( fillchar -- ) 200 0 DO DUP BUFFER I + C! LOOP DROP ;
	head BFILL,5,BFILL,docolon
	DW LIT,200h,LIT,0,XDO
BFILL1:	DW DUP,BUFFER,II,PLUS,CSTORE,XLOOP,BFILL1
	DW DROP,EXIT

; BFILLW ( fillword -- ) 100 0 DO DUP BUFFER I 2* + ! LOOP DROP ;
	head BFILLW,6,BFILLW,docolon
	DW LIT,100h,LIT,0,XDO
BFILL2: DW DUP,BUFFER,II,TWOSTAR,PLUS,STORE,XLOOP,BFILL2
	DW DROP,EXIT

; BPATTERN ( -- ) 200 0 DO I BUFFER I + C! LOOP ;
	head BPATTERN,8,BPATTERN,docolon
	DW LIT,200h,LIT,0,XDO
BPATT1:	DW BUFFER,II,PLUS,CSTORE,XLOOP,BPATT1
	DW EXIT

; BZERO ( -- ) 0 BFILLW ;
	head BZERO,5,BZERO,docolon
	DW LIT,0,BFILLW,EXIT

; MEMCMPW ( cmpchar -- addfail|-1 ) 100 0 DO DUP BUFFER I 2* + @ <> IF DROP I UNLOOP EXIT THEN LOOP DROP -1 ;
	head MEMCMPW,7,MEMCMPW,docolon
	DW LIT,100h,LIT,0,XDO
MEMCM1:	DW DUP,BUFFER,II,TWOSTAR,PLUS,FETCH,NOTEQUAL,qbranch,MEMCM2
	DW DROP,II,UNLOOP,branch,MEMCM3
MEMCM2: DW XLOOP,MEMCM1,DROP,LIT,-1
MEMCM3: DW EXIT

; TESTIT ( -- ) E5 BFILL 1 0 SWRITE 0 BFILL 1 0 SREAD ;
	head TESTIT,6,TESTIT,docolon
	DW LIT,0e5h,BFILL,LIT,1,LIT,0,SWRITE
	DW LIT,0,BFILL,LIT,1,LIT,0,SREAD
	DW EXIT

; GETSECTORCNT ( -- numberofsectors) IDENT BUFFER 72 + @ >< ;
	head GETSECTORCNT,12,GETSECTORCNT,docolon
	DW IDENT,BUFFER,LIT,72,PLUS,FETCH,SWAPBYTES,EXIT

; DISKZERO ( -- ) GETSECTORCNT BZERO 0 DO I 0 SWRITE I U. LOOP ;
	head DISKZERO,8,DISKZERO,docolon
	DW BZERO,LIT,0,XDO
DISKZ1:	DW II,LIT,0,SWRITE,II,UDOT,XLOOP,DISKZ1
	DW EXIT

; DISKFILL ( -- ) GETSECTORCNT 0 DO I BFILLW I 0 SWRITE I U. LOOP ;
	head DISKFILL,8,DISKFILL,docolon
	DW GETSECTORCNT,LIT,0,XDO
DISKF1:	DW II,BFILLW,II,LIT,0,SWRITE,II,UDOT,XLOOP,DISKF1
	DW EXIT

; DISKTEST ( -- badsector|-1) GETSECTORCNT 0 DO I 0 SREAD I MEMCMPW DUP -1 <> IF I UNLOOP EXIT THEN DROP I U. LOOP -1 ;
	head DISKTEST,8,DISKTEST,docolon
	DW GETSECTORCNT,LIT,0,XDO
DISKT1: DW II,LIT,0,SREAD,II,MEMCMPW,DUP,LIT,-1,NOTEQUAL,qbranch,DISKT2
	DW II,UNLOOP,branch,DISKT3
DISKT2:	DW DROP,II,UDOT,XLOOP,DISKT1,LIT,-1
DISKT3:	DW EXIT

; SETFEATURE ( featurecode -- ) WAITREADY R_FEATURES WREG EF CMD WAITREADY STATUS ;
	head SETFEATURE,10,SETFEATURE,docolon
	DW WAITREADY,R_FEATURES,WREG,LIT,0efh,CMD,WAITREADY,STATUS,EXIT

; SETWCACHE ( -- ) 02 SETFEATURE ;
	head SETWCACHE,9,SETWCACHE,docolon
	DW LIT,02h,SETFEATURE,EXIT

; SET8BIT ( -- ) 01 SETFEATURE ;
	head SET8BIT,7,SET8BIT,docolon
	DW LIT,01h,SETFEATURE,EXIT

; MODE8 ( -- ) RESET WAITREADY SET8BIT 8 IOMODE ! ;
	head MODE8,5,MODE8,docolon
	DW RESET,WAITREADY,SET8BIT,LIT,8,IOMODE,STORE,EXIT

; MODE16 ( -- ) RESET WAITREADY 10 IOMODE ! ;
	head MODE16,6,MODE16,docolon
	DW RESET,WAITREADY,LIT,16,IOMODE,STORE,EXIT

; 2LSHIFT ( d1 -- d1 )
	head TWOLSHIFT,7,2LSHIFT,docode
	pop	hl
	add	hl,hl	
	push	hl
	jr	nc,twols1
	ld	l,c
	ld	h,b
	adc	hl,hl
	ld	c,l
	ld	b,h
twols1:	next

; 2OR ( d1 d2 -- d1 ) ROT OR >R OR R> ;
	head TWOOR,3,2OR,docolon
	DW ROT,OR,TOR,OR,RFROM,EXIT

; MAKESECTOR ( n sl sh -- sh sl ) ROT 0 6 0 DO 2LSHIFT LOOP 2OR ;
	head MAKESECTOR,10,MAKESECTOR,docolon
	DW ROT,LIT,0,LIT,14,LIT,0,XDO
MAKES1:	DW TWOLSHIFT,XLOOP,MAKES1
	DW TWOOR,EXIT

; WRITEBOOT ( n -- ) 20 0 DO LOADERBASE 100 + I 200 * + BUFFER 200 CMOVE DUP I 0 MAKESECTOR SWRITE LOOP DROP ;
        head WRITEBOOT,9,WRITEBOOT,docolon
	DW LIT,20h,LIT,0,XDO
WRB1:	DW LOADERBASE,LIT,100h,PLUS,II,LIT,200h,STAR,PLUS,BUFFER,LIT,200h,CMOVE
	DW DUP,II,LIT,0,MAKESECTOR,SWRITE,XLOOP,WRB1
	DW DROP,EXIT

; READBOOT ( n -- ) 20 0 DO DUP I 0 MAKESECTOR SREAD BUFFER LOADERBASE 100 + I 200 * + 200 CMOVE LOOP DROP ;
	head READBOOT,8,READBOOT,docolon
	DW LIT,20h,LIT,0,XDO
READB1:	DW DUP,II,LIT,0,MAKESECTOR,SREAD,BUFFER,LOADERBASE,LIT,100h,PLUS,II
	DW LIT,200h,STAR,PLUS,LIT,200h,CMOVE,XLOOP,READB1
	DW DROP,EXIT

; WRITECOPIER ( -- ) LOADERBASE 100 0 FILL COPIER 1+ LOADERBASE COPIER C@ CMOVE ; ( Move code to copy 4100..7FFF to 0100..3FFF )
	head WRITECOPIER,11,WRITECOPIER,docolon
	DW LOADERBASE,LIT,100h,LIT,0,FILL,COPIER,ONEPLUS,LOADERBASE
	DW COPIER,CFETCH,CMOVE,EXIT

; WRITESKIPCOPIER ( -- ) LOADERBASE 100 0 FILL SKIPCOPIER 1+ LOADERBASE SKIPCOPIER C@ CMOVE ;
	head WRITESKIPCOPIER,15,WRITESKIPCOPIER,docolon
	DW LOADERBASE,LIT,100h,LIT,0,FILL,SKIPCOPIER,ONEPLUS,LOADERBASE
	DW SKIPCOPIER,CFETCH,CMOVE,EXIT

; JUMPLOADER ( -- ) C3 5 C! LOADERBASE 6 ! 0 0 BDOS ; ( Shouldn't ever return )
	head JUMPLOADER,10,JUMPLOADER,docolon
	DW LIT,0c3h,LIT,5,STORE,LOADERBASE,LIT,6,STORE
	DW LIT,0,LIT,0,BDOS,EXIT

; SKIPBOOT ( -- ) READBOOT WRITESKIPCOPIER JUMPLOADER ;
	head SKIPBOOT,8,SKIPBOOT,docolon
	DW READBOOT,WRITESKIPCOPIER,JUMPLOADER,EXIT

; NBOOT ( n -- ) R_STATUS 80 AND IF DROP ." BUSY!" ELSE DUP READBOOT WRITECOPIER FFFF C! JUMPLOADER THEN ;
	head NBOOT,5,NBOOT,docolon
	DW R_STATUS,LIT,80h,AND,qbranch,NBOOT1
	DW DROP,XSQUOTE
	DB 7,'BUSY!',00dh,00ah
	DW TYPE,NBOOT2
NBOOT1:	DW DUP,READBOOT,WRITECOPIER,LIT,0ffffh,CSTORE,JUMPLOADER
NBOOT2:	DW EXIT

; nboot ( -- ) Do this by hand to get the lower case word into the dictionary
        DW link
        DB 0
link    DEFL $
	DB 5,'nboot'
	call docolon
	DW NBOOT,EXIT

; BOOT ( -- ) R_STATUS 80 AND IF ." BUSY!" ELSE READBOOT WRITECOPIER JUMPLOADER THEN ;
	head BOOT,4,BOOT,docolon
	DW LIT,0,NBOOT,EXIT

; boot ( -- ) Do this by hand to get the lower case word into the dictionary
        DW link
        DB 0
link    DEFL $
	DB 4,'boot'
	call docolon
	DW BOOT,EXIT

; HELP ( -- ) 
	head HELP,4,HELP,docolon
	DW XSQUOTE
	DB HELP1-$-1
	DB 00dh,00ah,'.',00dh,00ah
	DB '. Type "BOOT" to boot from first 8MB volume on CF card',00dh,00ah
	DB '. Type "n NBOOT" to boot from the nth 8MB volume, '
	DB 'where "n" is a number',00dh,00ah
HELP1:	DW TYPE,XSQUOTE
	DB HELP2-$-1
	DB '. Type "WORDS" for the dictionary list',00dh,00ah
	DB '. Case matters: WORDS != words',00dh,00ah
	DB '. "BOOT" is aliased to "boot", "NBOOT" to "nboot"',00dh,00ah
	DB '.',00dh,00ah
HELP2:	DW TYPE,EXIT

; help ( -- ) Do this by hand to get the lower case word into the dictionary
        DW link
        DB 0
link    DEFL $
	DB 4,'help'
	call docolon
	DW HELP,EXIT
